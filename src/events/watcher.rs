use std::collections::HashSet;
use std::path::PathBuf;
use std::sync::mpsc as std_mpsc;
use std::time::{Duration, Instant};

use notify::{Config, Event, EventKind, RecommendedWatcher, RecursiveMode, Watcher};
use tokio::sync::mpsc;

use crate::library::track::AudioFormat;

/// Events generated by the file watcher
#[derive(Debug, Clone)]
pub enum WatchEvent {
    /// A new audio file was created
    FileCreated(PathBuf),
    /// An audio file was modified
    FileModified(PathBuf),
    /// An audio file was deleted
    FileDeleted(PathBuf),
    /// A watched folder was deleted
    FolderDeleted(PathBuf),
    /// An error occurred while watching
    Error(String),
}

/// Debounce duration for file system events
const DEBOUNCE_MS: u64 = 500;

/// Tracks pending events for debouncing
struct DebouncedEvents {
    created: HashSet<PathBuf>,
    modified: HashSet<PathBuf>,
    deleted: HashSet<PathBuf>,
    folder_deleted: HashSet<PathBuf>,
    last_event: Instant,
}

impl DebouncedEvents {
    fn new() -> Self {
        Self {
            created: HashSet::new(),
            modified: HashSet::new(),
            deleted: HashSet::new(),
            folder_deleted: HashSet::new(),
            last_event: Instant::now(),
        }
    }

    fn is_empty(&self) -> bool {
        self.created.is_empty()
            && self.modified.is_empty()
            && self.deleted.is_empty()
            && self.folder_deleted.is_empty()
    }

    fn clear(&mut self) {
        self.created.clear();
        self.modified.clear();
        self.deleted.clear();
        self.folder_deleted.clear();
    }
}

/// Multi-folder watcher with recursive monitoring and debouncing
pub struct MultiWatcher {
    watcher: RecommendedWatcher,
    watched_paths: HashSet<PathBuf>,
}

impl MultiWatcher {
    /// Create a new multi-folder watcher
    pub fn new(sender: mpsc::Sender<WatchEvent>) -> Result<Self, notify::Error> {
        let (tx, rx) = std_mpsc::channel();

        let watcher = RecommendedWatcher::new(
            {
                let tx = tx.clone();
                move |res: Result<Event, notify::Error>| {
                    let _ = tx.send(res);
                }
            },
            Config::default().with_poll_interval(Duration::from_secs(1)),
        )?;

        // Spawn the event processing task
        tokio::spawn(Self::process_events(rx, sender));

        Ok(Self {
            watcher,
            watched_paths: HashSet::new(),
        })
    }

    /// Start watching a folder recursively
    pub fn watch(&mut self, path: PathBuf) -> Result<(), notify::Error> {
        if !self.watched_paths.contains(&path) {
            self.watcher.watch(&path, RecursiveMode::Recursive)?;
            self.watched_paths.insert(path);
        }
        Ok(())
    }

    /// Stop watching a folder
    pub fn unwatch(&mut self, path: &PathBuf) -> Result<(), notify::Error> {
        if self.watched_paths.contains(path) {
            self.watcher.unwatch(path)?;
            self.watched_paths.remove(path);
        }
        Ok(())
    }

    /// Process events with debouncing
    async fn process_events(
        rx: std_mpsc::Receiver<Result<Event, notify::Error>>,
        sender: mpsc::Sender<WatchEvent>,
    ) {
        let mut debounced = DebouncedEvents::new();
        let debounce_duration = Duration::from_millis(DEBOUNCE_MS);

        loop {
            match rx.recv_timeout(Duration::from_millis(100)) {
                Ok(Ok(event)) => {
                    Self::accumulate_event(&mut debounced, event);
                }
                Ok(Err(e)) => {
                    let _ = sender.send(WatchEvent::Error(e.to_string())).await;
                }
                Err(std_mpsc::RecvTimeoutError::Timeout) => {
                    // Check if we should flush debounced events
                    if !debounced.is_empty()
                        && debounced.last_event.elapsed() >= debounce_duration
                    {
                        Self::flush_events(&mut debounced, &sender).await;
                    }
                }
                Err(std_mpsc::RecvTimeoutError::Disconnected) => {
                    break;
                }
            }
        }
    }

    /// Accumulate an event into the debounce buffer
    fn accumulate_event(debounced: &mut DebouncedEvents, event: Event) {
        for path in event.paths {
            match event.kind {
                EventKind::Create(_) => {
                    if Self::is_audio_file(&path) {
                        // If it was previously marked as deleted, remove that
                        debounced.deleted.remove(&path);
                        debounced.created.insert(path);
                    }
                }
                EventKind::Modify(_) => {
                    if Self::is_audio_file(&path) {
                        // Only mark as modified if it wasn't just created
                        if !debounced.created.contains(&path) {
                            debounced.modified.insert(path);
                        }
                    }
                }
                EventKind::Remove(_) => {
                    // For deletions, we can't check if it's an audio file since it's gone
                    // Check by extension
                    if Self::looks_like_audio_file(&path) {
                        debounced.created.remove(&path);
                        debounced.modified.remove(&path);
                        debounced.deleted.insert(path);
                    } else if !path.extension().is_some() {
                        // Might be a folder deletion
                        debounced.folder_deleted.insert(path);
                    }
                }
                _ => {}
            }
        }
        debounced.last_event = Instant::now();
    }

    /// Flush debounced events to the sender
    async fn flush_events(debounced: &mut DebouncedEvents, sender: &mpsc::Sender<WatchEvent>) {
        // Send created events
        for path in debounced.created.drain() {
            let _ = sender.send(WatchEvent::FileCreated(path)).await;
        }

        // Send modified events
        for path in debounced.modified.drain() {
            let _ = sender.send(WatchEvent::FileModified(path)).await;
        }

        // Send deleted events
        for path in debounced.deleted.drain() {
            let _ = sender.send(WatchEvent::FileDeleted(path)).await;
        }

        // Send folder deleted events
        for path in debounced.folder_deleted.drain() {
            let _ = sender.send(WatchEvent::FolderDeleted(path)).await;
        }

        debounced.clear();
    }

    /// Check if a path is an audio file (file must exist)
    fn is_audio_file(path: &PathBuf) -> bool {
        path.is_file() && Self::looks_like_audio_file(path)
    }

    /// Check if a path looks like an audio file based on extension
    fn looks_like_audio_file(path: &PathBuf) -> bool {
        path.extension()
            .and_then(|e| e.to_str())
            .map(|e| AudioFormat::from_extension(e) != AudioFormat::Unknown)
            .unwrap_or(false)
    }
}
